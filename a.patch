diff --git a/aiGuider_Server/app/services/ar/langgraph_agent/graph/__init__.py b/aiGuider_Server/app/services/ar/langgraph_agent/graph/__init__.py
index 3082b65..1add814 100644
--- a/aiGuider_Server/app/services/ar/langgraph_agent/graph/__init__.py
+++ b/aiGuider_Server/app/services/ar/langgraph_agent/graph/__init__.py
@@ -1,10 +1,14 @@
 """
-Graph模块
+LangGraph 图模块
 
-用于构建和管理LangGraph图
+提供构建LangGraph流程图的组件和工具
 """
 
-from .graph import build_agent_graph, AgentState
-from .nodes import analyze_image, retrieve_knowledge, generate_response
+from .graph import create_agent
+from .state import AgentState, MultiModalInput
 
-__all__ = ["build_agent_graph", "AgentState", "analyze_image", "retrieve_knowledge", "generate_response"] 
\ No newline at end of file
+__all__ = [
+    "create_agent",
+    "AgentState",
+    "MultiModalInput"
+] 
\ No newline at end of file
diff --git a/aiGuider_Server/app/services/ar/langgraph_agent/graph/graph.py b/aiGuider_Server/app/services/ar/langgraph_agent/graph/graph.py
index 28b0766..29690f2 100644
--- a/aiGuider_Server/app/services/ar/langgraph_agent/graph/graph.py
+++ b/aiGuider_Server/app/services/ar/langgraph_agent/graph/graph.py
@@ -1,140 +1,73 @@
 """
 图构建器
 
-构建LangGraph流程图的模块，仅负责图结构和流程的构建。
+构建LangGraph流程图的模块，实现ReAct模式的多模态Agent。
 """
 
-from typing import Any, Optional, Dict
+from typing import Dict, Any, Optional, List
 import logging
 from langgraph.graph import StateGraph, END
 from langgraph.checkpoint.base import BaseCheckpointSaver
-from langchain_core.messages import BaseMessage, SystemMessage, AIMessage
 
-from .state import AgentState # Import from new state module
+from .state import AgentState
 from .nodes import (
-    agent_node,
-    tools_node,
+    thinker_node,
+    router_node,
+    action_executor_node,
     error_handler_node
 )
 
 logger = logging.getLogger(__name__)
 
-# ReAct模式路由函数
-def should_continue(state: AgentState) -> str:
-    """
-    检查是否需要继续工具调用循环
-    
-    Args:
-        state: 当前状态
-        
-    Returns:
-        str: 下一个节点的名称 ("continue", "end" 或 "error")
-    """
-    # 检查是否有错误
-    if "error" in state and state["error"]:
-        return "error"
-    
-    # 获取消息列表
-    messages = state.get("messages", [])
-    
-    # 如果没有消息，无法继续
-    if not messages:
-        return "end"
-    
-    # 获取最后一条消息
-    last_message = messages[-1]
-    
-    # 检查是否是AI消息且包含工具调用
-    if isinstance(last_message, AIMessage) and hasattr(last_message, 'tool_calls') and last_message.tool_calls:
-        return "continue"
-    else:
-        return "end"
-
-def init_tools_node(state: AgentState, model: Any, image_analyzer: Any, knowledge_retriever: Any) -> Dict[str, Any]:
-    """
-    初始化工具节点
-    
-    将模型和工具添加到状态中
-    
-    Args:
-        state: 当前状态
-        model: 语言模型
-        image_analyzer: 图像分析器
-        knowledge_retriever: 知识检索器
-        
-    Returns:
-        Dict: 更新后的状态
-    """
-    logger.info("初始化工具")
-    
-    # 创建状态的副本
-    new_state = state.copy()
-    
-    # 添加工具到状态
-    tools = new_state.get("_tools", {})
-    tools["model"] = model
-    tools["image_analyzer"] = image_analyzer
-    tools["knowledge_retriever"] = knowledge_retriever
-    new_state["_tools"] = tools
-    
-    return new_state
-
-def build_agent_graph(
-    model: Any,
-    image_analyzer: Any,
-    knowledge_retriever: Any,
-    system_prompt: Optional[str],
-    checkpointer: Optional[BaseCheckpointSaver]
+def create_agent(
+    multimodal_model: Any, 
+    knowledge_searcher: Any,
+    checkpointer: Optional[BaseCheckpointSaver] = None
 ) -> StateGraph:
     """
-    构建Agent处理流程图
+    创建一个完整配置的多模态Agent
     
-    使用ReAct模式构建LangGraph循环流程，实现Agent的思考-行动循环
+    使用ReAct模式构建LangGraph循环流程
     
     Args:
-        model: 语言模型
-        image_analyzer: 图像分析器
-        knowledge_retriever: 知识检索器
-        system_prompt: 系统提示
-        checkpointer: 检查点存储器
+        multimodal_model: 多模态语言模型，能够直接分析图像内容
+        knowledge_searcher: 知识搜索工具，整合知识图谱和向量检索
+        checkpointer: 检查点存储器，用于状态持久化
         
     Returns:
-        StateGraph: 构建好的状态图
+        StateGraph: 构建好的Agent图
     """
     # 创建工作流图
     workflow = StateGraph(AgentState)
     
-    # 创建工具初始化函数，绑定所需参数
-    def init_tools(state: AgentState) -> Dict[str, Any]:
-        return init_tools_node(state, model, image_analyzer, knowledge_retriever)
-    
-    # 添加节点
-    workflow.add_node("init", init_tools)
-    workflow.add_node("agent", agent_node)
-    workflow.add_node("tools", tools_node)
-    workflow.add_node("error_handler", error_handler_node)
+    # 构建工具字典
+    tools = {
+        "knowledge_search": knowledge_searcher
+    }
     
-    # 设置入口点为初始化节点
-    workflow.set_entry_point("init")
+    # 添加所有节点
+    workflow.add_node("thinker", lambda state: thinker_node(state, multimodal_model))  # 核心思考节点
+    workflow.add_node("action_executor", lambda state: action_executor_node(state, tools))  # 工具执行节点
+    workflow.add_node("error_handler", error_handler_node)  # 错误处理节点
     
-    # 初始化完成后进入agent节点
-    workflow.add_edge("init", "agent")
+    # 设置入口点为思考节点
+    workflow.set_entry_point("thinker")
     
-    # 添加条件边
+    # 思考节点 -> 条件路由
     workflow.add_conditional_edges(
-        "agent",
-        should_continue,
+        "thinker",
+        router_node,
         {
-            "continue": "tools", 
-            "end": END,
-            "error": "error_handler"
+            "action_executor": "action_executor",  # 如果需要执行工具
+            "end": END,  # 如果可以直接生成回答或忽略
+            "error_handler": "error_handler"  # 如果发生错误
         }
     )
     
-    # 工具节点执行后回到agent节点，形成循环
-    workflow.add_edge("tools", "agent")
+    # 工具执行节点 -> 思考节点（形成循环）
+    workflow.add_edge("action_executor", "thinker")
     
-    # 错误处理后结束
+    # 错误处理节点 -> 结束
     workflow.add_edge("error_handler", END)
     
     # 编译图
diff --git a/aiGuider_Server/app/services/ar/langgraph_agent/graph/nodes.py b/aiGuider_Server/app/services/ar/langgraph_agent/graph/nodes.py
index 77bfa88..0f64dbd 100644
--- a/aiGuider_Server/app/services/ar/langgraph_agent/graph/nodes.py
+++ b/aiGuider_Server/app/services/ar/langgraph_agent/graph/nodes.py
@@ -1,543 +1,233 @@
 """
-图节点定义
+节点实现
 
-定义LangGraph流程图中的节点函数
+定义LangGraph Agent流程图的所有节点函数
 """
 
-from typing import Dict, Any, List, Optional
 import logging
-import copy
+from typing import Dict, Any, List, Tuple, Optional
+from datetime import datetime
+
+from langchain_core.messages import HumanMessage, AIMessage, ToolMessage, SystemMessage
 
-from langchain_core.messages import SystemMessage, HumanMessage, AIMessage
-from langgraph.graph import END
-from ..tools.image_analyzer import ImageAnalyzer
-from ..tools.knowledge_retriever import KnowledgeRetriever
 from .state import AgentState
+from ..prompts.templates import load_thinker_prompt
 
 logger = logging.getLogger(__name__)
 
-def analyze_image(
-    state: Dict[str, Any],
-    image_analyzer: ImageAnalyzer
-) -> Dict[str, Any]:
+def thinker_node(state: AgentState, multimodal_model: Any) -> Dict[str, Any]:
     """
-    分析图像节点
+    核心思考节点
     
-    从状态中提取图像，使用图像分析器进行分析
+    分析多模态输入，决定是否需要响应，判断是直接回答还是调用工具
     
     Args:
         state: 当前状态
-        image_analyzer: 图像分析器
+        multimodal_model: 多模态语言模型
         
     Returns:
-        Dict: 更新后的状态
-    """
-    logger.info("开始分析图像")
-    
-    # 创建状态的副本，避免直接修改原始状态
-    new_state = copy.deepcopy(state)
-    
-    # 从状态中获取消息
-    messages = new_state.get("messages", [])
-    
-    # 检查是否有用户消息
-    user_messages = [m for m in messages if isinstance(m, HumanMessage)]
-    if not user_messages:
-        logger.warning("没有找到用户消息")
-        new_state["image_analysis_result"] = ""
-        return new_state
-    
-    # 获取最后一条用户消息
-    last_user_msg = user_messages[-1]
-    
-    # 检查消息内容是否包含图像
-    if not isinstance(last_user_msg.content, list):
-        logger.info("用户消息中没有图像内容")
-        new_state["image_analysis_result"] = ""
-        return new_state
-    
-    # 提取图像内容
-    image_parts = [
-        part for part in last_user_msg.content 
-        if isinstance(part, dict) and part.get("type") == "image_url"
-    ]
-    
-    if not image_parts:
-        logger.info("用户消息中没有图像URL")
-        new_state["image_analysis_result"] = ""
-        return new_state
-    
-    # 获取第一个图像URL
-    image_url = image_parts[0].get("image_url", {}).get("url", "")
-    
-    if not image_url:
-        logger.warning("图像URL为空")
-        new_state["image_analysis_result"] = ""
-        return new_state
-    
-    # 分析图像
-    try:
-        analysis_result = image_analyzer.analyze(image_url)
-        if analysis_result:
-            logger.info(f"图像分析完成: {analysis_result[:100]}...")
-            new_state["image_analysis_result"] = analysis_result
-        else:
-            logger.warning("图像分析结果为空")
-            new_state["image_analysis_result"] = "无法获取图像分析结果"
-    except Exception as e:
-        logger.error(f"图像分析出错: {e}", exc_info=True)
-        new_state["image_analysis_result"] = f"图像分析失败: {str(e)}"
-    
-    return new_state
-
-def retrieve_knowledge(
-    state: Dict[str, Any],
-    knowledge_retriever: KnowledgeRetriever
-) -> Dict[str, Any]:
+        更新后的状态，包含思考结果
     """
-    检索知识节点
-    
-    基于图像分析结果和用户问题检索相关知识
+    logger.info("思考节点执行")
     
-    Args:
-        state: 当前状态
-        knowledge_retriever: 知识检索器
-        
-    Returns:
-        Dict: 更新后的状态
-    """
-    logger.info("开始检索知识")
+    # 初始化处理时间（原start_node功能）
+    state.last_interaction_time = datetime.now()
     
-    # 创建状态的副本
-    new_state = copy.deepcopy(state)
+    if not state.messages:
+        logger.warning("消息为空，无法执行思考节点")
+        return {**state.model_dump(), "final_answer": "无法处理空消息"}
     
-    # 获取图像分析结果
-    image_analysis = new_state.get("image_analysis_result", "")
+    # 获取最新的用户消息和多模态输入
+    last_message = state.messages[-1]
+    input_data = state.current_input
     
-    # 从状态中获取消息
-    messages = new_state.get("messages", [])
+    # 直接使用传入的多模态模型，不从状态中获取
+    if not multimodal_model:
+        logger.error("未找到多模态模型")
+        return {**state.model_dump(), "safety_issues": ["未找到多模态模型"]}
     
-    # 提取用户问题
-    user_question = ""
-    user_messages = [m for m in messages if isinstance(m, HumanMessage)]
-    if user_messages:
-        # 获取最后一条用户消息中的文本
-        last_user_msg = user_messages[-1]
-        if isinstance(last_user_msg.content, str):
-            user_question = last_user_msg.content
-        elif isinstance(last_user_msg.content, list):
-            # 提取文本部分
-            text_parts = [
-                part.get("text", "") 
-                for part in last_user_msg.content 
-                if isinstance(part, dict) and part.get("type") == "text"
-            ]
-            user_question = " ".join(text_parts)
+    # 构建提示
+    prompt = []
     
-    # 如果没有有效的分析结果或问题，跳过知识检索
-    if not image_analysis and not user_question:
-        logger.info("没有足够信息进行知识检索")
-        new_state["knowledge"] = ""
-        return new_state
+    # 添加系统消息
+    thinker_prompt = load_thinker_prompt()
+    prompt.append(SystemMessage(content=thinker_prompt))
     
-    # 组合查询内容
-    query = f"{image_analysis} {user_question}".strip()
+    # 添加历史消息
+    prompt.extend(state.messages)
     
-    # 检索知识
+    # 调用模型进行思考
     try:
-        knowledge = knowledge_retriever.retrieve(query)
-        if knowledge:
-            logger.info(f"知识检索完成: {knowledge[:100]}...")
-            new_state["knowledge"] = knowledge
-        else:
-            logger.info("知识检索未返回结果")
-            new_state["knowledge"] = ""
-    except Exception as e:
-        logger.error(f"知识检索出错: {e}", exc_info=True)
-        new_state["knowledge"] = ""
-    
-    return new_state
-
-def generate_response(
-    state: Dict[str, Any],
-    model: Any
-) -> Dict[str, Any]:
-    """
-    生成回复节点
-    
-    基于图像分析结果、检索的知识和用户问题生成回复
-    
-    Args:
-        state: 当前状态
-        model: 语言模型
-        
-    Returns:
-        Dict: 更新后的状态
-    """
-    logger.info("开始生成回复")
-    
-    # 创建状态的副本
-    new_state = copy.deepcopy(state)
-    
-    # 获取状态数据
-    messages = new_state.get("messages", [])
-    image_analysis = new_state.get("image_analysis_result", "")
-    knowledge = new_state.get("knowledge", "")
-    
-    # 如果没有消息，返回错误提示
-    if not messages:
-        logger.error("消息列表为空")
-        new_state["response"] = "抱歉，我无法处理空的消息列表。"
-        return new_state
-    
-    # 创建系统消息
-    system_prompt = messages[0].content if messages and isinstance(messages[0], SystemMessage) else ""
-    
-    # 如果有图像分析结果和知识，添加到系统提示
-    additional_context = ""
-    if image_analysis:
-        additional_context += f"\n\n图像分析结果: {image_analysis}"
-    if knowledge:
-        additional_context += f"\n\n相关知识: {knowledge}"
-    
-    # 如果有额外上下文，创建一个新的系统消息
-    if additional_context and messages:
-        enhanced_system_prompt = system_prompt + additional_context
-        messages = [SystemMessage(content=enhanced_system_prompt)] + messages[1:]
-    
-    # 生成回复
-    try:
-        response = model.invoke(messages)
-        if response and hasattr(response, 'content'):
-            response_text = response.content
-            logger.info(f"生成回复完成: {response_text[:100]}...")
+        response = multimodal_model(prompt)
+        content = response.content if hasattr(response, "content") else str(response)
+        
+        # 检查是否需要忽略
+        if "IGNORE_SIGNAL" in content:
+            logger.info("思考节点决定忽略当前输入")
+            return {**state.model_dump(), "final_answer": ""}
+        
+        # 检查是否有工具调用
+        if "TOOL_CALL:" in content:
+            logger.info("思考节点决定调用工具")
+            # 解析工具调用
+            tool_parts = content.split("TOOL_CALL:")[1].strip().split("\n")
+            tool_name = None
+            tool_query = None
             
-            # 添加AI回复到消息历史
-            messages.append(AIMessage(content=response_text))
+            for part in tool_parts:
+                if part.startswith("工具:"):
+                    tool_name = part.replace("工具:", "").strip()
+                elif part.startswith("查询:"):
+                    tool_query = part.replace("查询:", "").strip()
             
-            # 更新状态
-            new_state["messages"] = messages
-            new_state["response"] = response_text
-        else:
-            logger.warning("模型返回了无效的响应")
-            new_state["response"] = "抱歉，我生成回复时遇到了问题。请稍后再试。"
-    except Exception as e:
-        logger.error(f"生成回复出错: {e}", exc_info=True)
-        new_state["response"] = "抱歉，我在处理您的请求时遇到了问题。请稍后再试。"
-    
-    return new_state 
-
-def image_analyzer_node(state: AgentState) -> Dict[str, Any]:
-    """
-    图像分析节点包装函数
-    
-    Args:
-        state: 当前状态
+            if tool_name and tool_query:
+                # 添加工具调用到状态
+                state.messages.append(AIMessage(content=content))
+                return {
+                    **state.model_dump(),
+                    "action_name": tool_name,
+                    "action_input": {"query": tool_query}
+                }
         
-    Returns:
-        Dict: 更新后的状态
-    """
-    logger.info("执行图像分析节点")
-    try:
-        # 从状态上下文中获取图像分析器
-        image_analyzer = state.get("_tools", {}).get("image_analyzer")
-        if not image_analyzer:
-            raise ValueError("图像分析器未在状态中找到")
+        # 直接生成最终答案
+        if "FINAL_ANSWER:" in content:
+            answer = content.split("FINAL_ANSWER:")[1].strip()
+            logger.info("思考节点生成了最终答案")
             
-        state_update = analyze_image(state, image_analyzer)
-        return state_update
-    except Exception as e:
-        logger.error(f"图像分析节点执行出错: {e}", exc_info=True)
-        return {
-            **state,
-            "error": f"图像分析失败: {str(e)}"
-        }
-
-def knowledge_retriever_node(state: AgentState) -> Dict[str, Any]:
-    """
-    知识检索节点包装函数
-    
-    Args:
-        state: 当前状态
+            # 添加最终答案到状态
+            state.messages.append(AIMessage(content=answer))
+            return {**state.model_dump(), "final_answer": answer}
         
-    Returns:
-        Dict: 更新后的状态
-    """
-    logger.info("执行知识检索节点")
-    try:
-        # 从状态上下文中获取知识检索器
-        knowledge_retriever = state.get("_tools", {}).get("knowledge_retriever")
-        if not knowledge_retriever:
-            raise ValueError("知识检索器未在状态中找到")
-            
-        state_update = retrieve_knowledge(state, knowledge_retriever)
-        return state_update
-    except Exception as e:
-        logger.error(f"知识检索节点执行出错: {e}", exc_info=True)
-        return {
-            **state,
-            "error": f"知识检索失败: {str(e)}"
-        }
-
-def response_generator_node(state: AgentState) -> Dict[str, Any]:
-    """
-    回复生成节点包装函数
+        # 未找到明确的行动指令，将全部内容作为回答
+        logger.info("思考节点生成了不带标记的答案")
+        state.messages.append(AIMessage(content=content))
+        return {**state.model_dump(), "final_answer": content}
     
-    Args:
-        state: 当前状态
-        
-    Returns:
-        Dict: 更新后的状态
-    """
-    logger.info("执行回复生成节点")
-    try:
-        # 从状态上下文中获取模型
-        model = state.get("_tools", {}).get("model")
-        if not model:
-            raise ValueError("语言模型未在状态中找到")
-            
-        state_update = generate_response(state, model)
-        return state_update
     except Exception as e:
-        logger.error(f"回复生成节点执行出错: {e}", exc_info=True)
-        return {
-            **state,
-            "error": f"生成回复失败: {str(e)}"
-        }
+        logger.error(f"思考节点执行出错: {e}", exc_info=True)
+        return {**state.model_dump(), "safety_issues": [f"思考过程发生错误: {str(e)}"]}
 
-def error_handler_node(state: AgentState) -> Dict[str, Any]:
+def router_node(state: AgentState) -> str:
     """
-    错误处理节点
+    路由节点
     
-    处理流程中的错误，生成友好的错误消息
+    根据思考节点的输出决定下一步流程
     
     Args:
         state: 当前状态
         
     Returns:
-        Dict: 更新后的状态
+        下一个节点的名称
     """
-    logger.info("执行错误处理节点")
-    
-    # 创建状态的副本
-    new_state = copy.deepcopy(state)
-    
-    # 获取错误信息
-    error_msg = new_state.get("error", "未知错误")
-    logger.error(f"处理错误: {error_msg}")
+    logger.info("路由节点执行")
     
-    # 获取消息历史
-    messages = new_state.get("messages", [])
+    # 检查安全问题
+    if state.safety_issues:
+        logger.warning(f"检测到安全问题: {state.safety_issues}")
+        return "error_handler"
     
-    # 创建错误响应
-    friendly_error_msg = f"抱歉，我在处理您的请求时遇到了问题: {error_msg}。请重新尝试或换一种方式提问。"
+    # 检查是否有最终答案
+    if state.final_answer is not None:
+        logger.info("已生成最终答案，流程结束")
+        return "end"
     
-    # 添加错误消息到历史
-    messages.append(AIMessage(content=friendly_error_msg))
-    new_state["messages"] = messages
-    
-    # 清除错误状态，防止无限循环
-    new_state.pop("error", None)
+    # 检查是否有工具调用
+    if state.action_name and state.action_input:
+        logger.info("检测到工具调用，进入工具节点")
+        return "action_executor"
     
-    return new_state
+    # 默认返回错误处理节点
+    logger.warning("节点输出不明确，进入错误处理")
+    return "error_handler"
 
-def agent_node(state: AgentState) -> Dict[str, Any]:
+def action_executor_node(state: AgentState, tools: Dict[str, Any]) -> Dict[str, Any]:
     """
-    ReAct模式的Agent节点
+    工具执行节点
     
-    作为决策中心，处理用户输入，决定接下来的行动
-    - 分析图像
-    - 检索知识
-    - 生成回复
+    执行思考节点决定的工具调用
     
     Args:
         state: 当前状态
+        tools: 可用工具字典
         
     Returns:
-        Dict: 带有下一步行动的状态更新
+        更新后的状态，包含工具执行结果
     """
-    logger.info("执行Agent决策节点")
+    logger.info("工具执行节点执行")
     
-    # 创建状态的副本
-    new_state = copy.deepcopy(state)
+    if not state.action_name or not state.action_input:
+        logger.warning("没有工具调用需要执行")
+        return {**state.model_dump(), "safety_issues": ["工具调用信息不完整"]}
     
-    # 获取状态数据
-    messages = new_state.get("messages", [])
-    tools = new_state.get("_tools", {})
-    model = tools.get("model")
+    # 获取工具名称和参数
+    tool_name = state.action_name
+    tool_args = state.action_input
     
-    if not model:
-        logger.error("语言模型未在状态中找到")
-        new_state["error"] = "缺少必要的语言模型"
-        return new_state
+    # 检查工具是否存在
+    if not tools or tool_name not in tools:
+        error_msg = f"未找到工具: {tool_name}"
+        logger.error(error_msg)
+        return {**state.model_dump(), "safety_issues": [error_msg]}
     
-    # 创建工具定义列表
-    tool_definitions = [
-        {
-            "type": "function",
-            "function": {
-                "name": "analyze_image",
-                "description": "分析用户提供的图像，识别其中的内容，特别是地标、景点等",
-                "parameters": {
-                    "type": "object",
-                    "properties": {},
-                    "required": []
-                }
-            }
-        },
-        {
-            "type": "function",
-            "function": {
-                "name": "retrieve_knowledge",
-                "description": "根据图像分析结果和用户问题，检索相关的知识和信息",
-                "parameters": {
-                    "type": "object",
-                    "properties": {
-                        "query": {
-                            "type": "string",
-                            "description": "搜索查询，可以是图像分析结果或用户问题"
-                        }
-                    },
-                    "required": ["query"]
-                }
-            }
+    # 执行工具调用
+    try:
+        tool = tools[tool_name]
+        if tool_name == "knowledge_search":
+            result = tool.search(**tool_args)
+        else:
+            logger.warning(f"未知的工具类型: {tool_name}")
+            result = f"不支持的工具: {tool_name}"
+        
+        # 添加工具消息
+        tool_message = ToolMessage(
+            content=result,
+            name=tool_name
+        )
+        state.messages.append(tool_message)
+        
+        # 记录工具执行结果
+        state.action_output = result
+        
+        # 清除当前的工具调用信息，为下一次调用做准备
+        action_result = {
+            **state.model_dump(),
+            "action_output": result,
         }
-    ]
-    
-    # 如果已有图像分析结果，添加到系统消息中
-    if new_state.get("image_analysis_result"):
-        # 查找系统消息或创建新的
-        has_system_msg = False
-        for i, msg in enumerate(messages):
-            if isinstance(msg, SystemMessage):
-                has_system_msg = True
-                # 更新系统消息，添加图像分析信息
-                original_content = msg.content
-                if "图像分析结果:" not in original_content:
-                    messages[i] = SystemMessage(content=f"{original_content}\n\n图像分析结果: {new_state['image_analysis_result']}")
-                break
-        
-        # 如果没有系统消息，创建一个
-        if not has_system_msg and messages:
-            messages.insert(0, SystemMessage(content=f"图像分析结果: {new_state['image_analysis_result']}"))
-    
-    # 如果已有知识检索结果，添加到系统消息中
-    if new_state.get("knowledge"):
-        # 查找系统消息或创建新的
-        has_system_msg = False
-        for i, msg in enumerate(messages):
-            if isinstance(msg, SystemMessage):
-                has_system_msg = True
-                # 更新系统消息，添加知识信息
-                original_content = msg.content
-                if "相关知识:" not in original_content:
-                    messages[i] = SystemMessage(content=f"{original_content}\n\n相关知识: {new_state['knowledge']}")
-                break
         
-        # 如果没有系统消息，创建一个
-        if not has_system_msg and messages:
-            messages.insert(0, SystemMessage(content=f"相关知识: {new_state['knowledge']}"))
+        logger.info(f"工具 {tool_name} 执行完成")
+        return action_result
     
-    try:
-        # 配置模型使用工具
-        model_with_tools = model.bind_tools(tool_definitions)
-        
-        # 调用模型进行决策
-        response = model_with_tools.invoke(messages)
-        
-        # 将模型响应添加到消息历史
-        messages.append(response)
-        new_state["messages"] = messages
-        
-        return new_state
     except Exception as e:
-        logger.error(f"Agent决策出错: {e}", exc_info=True)
-        new_state["error"] = f"决策过程出错: {str(e)}"
-        return new_state
+        error_msg = f"工具 {tool_name} 执行出错: {str(e)}"
+        logger.error(error_msg, exc_info=True)
+        return {**state.model_dump(), "safety_issues": [error_msg]}
 
-def tools_node(state: AgentState) -> Dict[str, Any]:
+def error_handler_node(state: AgentState) -> Dict[str, Any]:
     """
-    工具执行节点
+    错误处理节点
     
-    执行Agent决定调用的工具
+    处理流程中的异常
     
     Args:
         state: 当前状态
         
     Returns:
-        Dict: 工具执行结果的状态更新
+        更新后的状态，包含错误处理结果
     """
-    logger.info("执行工具节点")
-    
-    # 创建状态的副本
-    new_state = copy.deepcopy(state)
+    logger.info("错误处理节点执行")
     
-    # 获取消息
-    messages = new_state.get("messages", [])
-    if not messages:
-        logger.error("消息列表为空")
-        new_state["error"] = "消息列表为空"
-        return new_state
+    # 获取安全问题列表
+    safety_issues = state.safety_issues
     
-    # 获取最后一条AI消息
-    ai_messages = [m for m in messages if isinstance(m, AIMessage)]
-    if not ai_messages:
-        logger.error("没有找到AI消息")
-        new_state["error"] = "没有找到AI消息"
-        return new_state
-    
-    last_ai_msg = ai_messages[-1]
-    
-    # 检查是否有工具调用
-    if not hasattr(last_ai_msg, 'tool_calls') or not last_ai_msg.tool_calls:
-        logger.info("AI消息中没有工具调用")
-        return new_state
+    # 生成错误消息
+    error_message = "抱歉，处理您的请求时遇到了问题: "
     
-    # 获取工具
-    tools = new_state.get("_tools", {})
-    image_analyzer = tools.get("image_analyzer")
-    knowledge_retriever = tools.get("knowledge_retriever")
+    if safety_issues:
+        error_message += f"{'; '.join(safety_issues)}"
+    else:
+        error_message += "未知错误"
     
-    # 处理每个工具调用
-    for tool_call in last_ai_msg.tool_calls:
-        tool_name = tool_call.get("name", "")
-        
-        if tool_name == "analyze_image" and image_analyzer:
-            try:
-                result = analyze_image(new_state, image_analyzer)
-                new_state["image_analysis_result"] = result.get("image_analysis_result", "")
-            except Exception as e:
-                logger.error(f"图像分析工具执行出错: {e}", exc_info=True)
-                new_state["error"] = f"图像分析工具执行出错: {str(e)}"
-        
-        elif tool_name == "retrieve_knowledge" and knowledge_retriever:
-            args = tool_call.get("args", {})
-            query = args.get("query", "")
-            
-            # 如果没有提供查询，使用图像分析结果
-            if not query and new_state.get("image_analysis_result"):
-                query = new_state["image_analysis_result"]
-            
-            if query:
-                try:
-                    result = retrieve_knowledge({"messages": messages, "image_analysis_result": new_state.get("image_analysis_result", "")}, knowledge_retriever)
-                    new_state["knowledge"] = result.get("knowledge", "")
-                except Exception as e:
-                    logger.error(f"知识检索工具执行出错: {e}", exc_info=True)
-                    new_state["error"] = f"知识检索工具执行出错: {str(e)}"
-    
-    # 添加工具结果消息
-    if new_state.get("image_analysis_result") or new_state.get("knowledge"):
-        tool_result = ""
-        if new_state.get("image_analysis_result"):
-            tool_result += f"图像分析结果: {new_state['image_analysis_result']}\n\n"
-        if new_state.get("knowledge"):
-            tool_result += f"知识检索结果: {new_state['knowledge']}"
-        
-        # 添加工具消息到历史
-        # 注意：这里不是LangChain的标准ToolMessage，我们用AIMessage来模拟工具结果
-        # 更完善的实现应该使用专门的工具消息类型
-        messages.append(AIMessage(content=tool_result))
-        new_state["messages"] = messages
+    logger.warning(f"错误处理: {error_message}")
     
-    return new_state 
\ No newline at end of file
+    # 添加错误消息到状态
+    return {**state.model_dump(), "final_answer": error_message} 
\ No newline at end of file
diff --git a/aiGuider_Server/app/services/ar/langgraph_agent/graph/state.py b/aiGuider_Server/app/services/ar/langgraph_agent/graph/state.py
index 6bbd7af..26cf3c8 100644
--- a/aiGuider_Server/app/services/ar/langgraph_agent/graph/state.py
+++ b/aiGuider_Server/app/services/ar/langgraph_agent/graph/state.py
@@ -1,14 +1,44 @@
 """
-状态定义模块
+状态定义
+
+定义LangGraph流程图中使用的状态类型。
 """
-from typing import List, Optional, TypedDict
-from langchain_core.messages import BaseMessage
-
-# 定义状态类型
-class AgentState(TypedDict):
-    """Agent的状态定义"""
-    messages: List[BaseMessage]  # 消息历史
-    image_analysis_result: Optional[str]  # 图像分析结果
-    knowledge: Optional[str]  # 检索到的知识
-    error: Optional[str]  # 错误信息
-    _tools: Optional[dict] # 用于传递工具实例 (新增) 
\ No newline at end of file
+
+from typing import List, Dict, Any, Optional, Tuple, Union
+from datetime import datetime
+from pydantic import BaseModel, Field
+
+class MultiModalInput(BaseModel):
+    """多模态输入的定义，支持文本和图像"""
+    
+    text: str = Field(default="", description="用户文本输入")
+    image_urls: List[str] = Field(default_factory=list, description="图像URL列表")
+
+class AgentState(BaseModel):
+    """
+    Agent状态类, 包含多模态交互所需的所有状态
+    
+    遵循ReAct模式，存储消息历史、当前输入、工具输出和最终回答
+    """
+    # 消息历史
+    messages: List[Dict[str, Any]] = Field(default_factory=list, description="消息历史记录")
+    
+    # 当前输入 - 可能是文本或多模态内容
+    current_input: Optional[MultiModalInput] = Field(default=None, description="当前处理的输入")
+    
+    # 工具使用
+    action_name: Optional[str] = Field(default=None, description="待执行工具名称")
+    action_input: Optional[Dict[str, Any]] = Field(default=None, description="工具输入参数")
+    action_output: Optional[str] = Field(default=None, description="工具执行结果")
+    
+    # 安全检查
+    safety_issues: List[str] = Field(default_factory=list, description="安全问题列表")
+    
+    # 最终输出
+    final_answer: Optional[str] = Field(default=None, description="生成的最终回答")
+    
+    # 交互时间记录
+    last_interaction_time: datetime = Field(default_factory=datetime.now)
+    
+    class Config:
+        arbitrary_types_allowed = True 
\ No newline at end of file
diff --git a/aiGuider_Server/app/services/ar/langgraph_agent/llms/qwen.py b/aiGuider_Server/app/services/ar/langgraph_agent/llms/qwen.py
index 92a564b..28b3a18 100644
--- a/aiGuider_Server/app/services/ar/langgraph_agent/llms/qwen.py
+++ b/aiGuider_Server/app/services/ar/langgraph_agent/llms/qwen.py
@@ -82,6 +82,7 @@ class QwenVLModel(BaseChatModel):
                 streaming=config.streaming,
                 model_kwargs=config.model_kwargs or {},
             )
+            # logger.info(f"通义千问模型 (ChatTongyi) 客户端初始化成功: {config}")
         except Exception as e:
             error_message = f"通义千问模型 (ChatTongyi) 客户端初始化失败: {e}"
             logger.error(f"{error_message} [错误码: {ErrorCodes.MODEL_INIT_FAILED}]", exc_info=True)
diff --git a/aiGuider_Server/app/services/ar/langgraph_agent/main.py b/aiGuider_Server/app/services/ar/langgraph_agent/main.py
index 71ecb9c..08e8b48 100644
--- a/aiGuider_Server/app/services/ar/langgraph_agent/main.py
+++ b/aiGuider_Server/app/services/ar/langgraph_agent/main.py
@@ -7,21 +7,19 @@ AR智能导游Agent主入口
 import asyncio
 import logging
 import os
-import sys
-from typing import Dict, List, Optional, Any, Union
+from typing import Dict, Optional, Union
 import base64
-from pathlib import Path
+from datetime import datetime
 
 from langchain_core.messages import HumanMessage, SystemMessage
-from langgraph.graph import StateGraph, END
 from langgraph.checkpoint.memory import MemorySaver
 
 from .config.model_config import load_model_config, ConfigError
-from .graph.graph import build_agent_graph
+from .graph.graph import create_agent
 from .llms.qwen import get_qwen_model
-from .tools.image_analyzer import ImageAnalyzer
-from .tools.knowledge_retriever import KnowledgeRetriever
+from .tools.knowledge_searcher import KnowledgeSearcher
 from .prompts.templates import load_system_prompt
+from .graph.state import MultiModalInput
 
 logger = logging.getLogger(__name__)
 
@@ -30,7 +28,7 @@ class ARGuideAgent:
     AR智能导游Agent类
     
     这个类封装了AR智能导游系统的多模态AI Agent，使用LangGraph构建流程图，
-    集成不同的多模态模型处理图像和文本输入。
+    集成多模态模型处理图像和文本输入。
     """
     
     def __init__(self, model_name: str):
@@ -45,30 +43,26 @@ class ARGuideAgent:
             RuntimeError: 当模型初始化失败时抛出
         """
         try:
-            # 从配置文件加载模型配置
+            # 从配置文件加载模型配置，用于初始化模型
             self.config = load_model_config(model_name)
             
-            # 根据模型名称初始化对应的模型
+            # 初始化多模态模型
             self.model = self._initialize_model(model_name)
             
-            # 加载系统提示
-            self.system_prompt = load_system_prompt()
-            
-            # 初始化工具
-            self.image_analyzer = ImageAnalyzer(self.model)
-            self.knowledge_retriever = KnowledgeRetriever()
+            # 初始化知识搜索工具
+            self.knowledge_searcher = KnowledgeSearcher()
             
             # 初始化检查点管理器
             self.checkpointer = MemorySaver()
             
             # 构建Agent图
-            self.graph = build_agent_graph(
-                model=self.model,
-                image_analyzer=self.image_analyzer,
-                knowledge_retriever=self.knowledge_retriever,
-                system_prompt=self.system_prompt,
+            logger.info("创建多模态Agent图...")
+            self.graph = create_agent(
+                multimodal_model=self.model,
+                knowledge_searcher=self.knowledge_searcher,
                 checkpointer=self.checkpointer
             )
+            logger.info("多模态Agent图创建完成")
             
         except ConfigError as e:
             # 配置错误是严重错误，记录并重新抛出
@@ -103,7 +97,7 @@ class ARGuideAgent:
             # elif model_name.startswith("gemini"):
             #     return get_gemini_model(self.config)
             else:
-                logger.warning(f"未知的模型类型: {model_name}，尝试使用默认的Qwen模型")
+                logger.warning(f"未知的模型类型: {model_name}，使用默认的Qwen模型")
                 return get_qwen_model(self.config)
         except Exception as e:
             error_message = f"初始化模型 {model_name} 失败: {str(e)}"
@@ -125,19 +119,11 @@ class ARGuideAgent:
         Returns:
             包含回复文本的字典
         """
-        # 准备输入
-        messages = []
-        
-        # 添加系统消息
-        messages.append(SystemMessage(content=self.system_prompt))
-        
-        # 创建用户消息内容
-        content = []
+        # 准备系统消息
+        system_message = SystemMessage(content=load_system_prompt())
         
-        # 添加文本内容
-        content.append({"type": "text", "text": text_query})
-        
-        # 如果有图像，添加图像内容
+        # 处理图像数据
+        image_url = None
         if image_data:
             # 如果是字节数据，转换为base64
             if isinstance(image_data, bytes):
@@ -146,17 +132,33 @@ class ARGuideAgent:
             # 确保image_data是base64字符串
             if not image_data.startswith('data:image'):
                 image_data = f"data:image/jpeg;base64,{image_data}"
-                
-            content.append({"type": "image_url", "image_url": {"url": image_data}})
+            
+            image_url = image_data
+        
+        # 创建用户消息内容
+        content = []
+        
+        # 添加文本内容
+        if text_query:
+            content.append({"type": "text", "text": text_query})
+        
+        # 如果有图像，添加图像内容
+        if image_url:
+            content.append({"type": "image_url", "image_url": {"url": image_url}})
         
         # 添加人类消息
-        messages.append(HumanMessage(content=content))
+        user_message = HumanMessage(content=content)
         
         # 准备状态
         state = {
-            "messages": messages,
-            "session_id": session_id,
-            "response": ""
+            "messages": [system_message, user_message],
+            "input": MultiModalInput(
+                image_url=image_url,
+                text=text_query,
+                context="",
+                timestamp=datetime.now()
+            ),
+            "should_respond": True
         }
         
         # 配置运行时参数
@@ -164,7 +166,7 @@ class ARGuideAgent:
         if session_id and self.checkpointer:
             config["configurable"] = {"thread_id": session_id}
         
-        # 异步执行图 - 使用流式处理获取结果
+        # 异步执行图
         try:
             final_result = {"response": "", "status": "success"}
             
@@ -172,21 +174,28 @@ class ARGuideAgent:
             async for event in self.graph.astream(state, config):
                 if "response" in event:
                     final_result["response"] = event["response"]
+                elif "error" in event:
+                    final_result["status"] = "error"
+                    final_result["error"] = event["error"]
+                elif "safety_issues" in event and event["safety_issues"]:
+                    final_result["status"] = "safety_filtered"
+                    final_result["safety_issues"] = event["safety_issues"]
                     
+            # 如果Agent决定不响应，返回空响应
+            if "should_respond" in event and not event["should_respond"]:
+                final_result["status"] = "no_response_needed"
+                
             return final_result
         except Exception as e:
             # 记录详细错误信息
             error_id = f"err_{hash(e)%10000:04d}"
             logger.error(f"处理查询时出错 [ID: {error_id}]: {e}", exc_info=True)
             
-            # 降级响应
-            error_response = {
+            return {
                 "response": "很抱歉，我处理您的请求时遇到了问题。请稍后再试。", 
                 "status": "error",
                 "error_id": error_id
             }
-            
-            return error_response
 
 
 # 创建单例实例
diff --git a/aiGuider_Server/app/services/ar/langgraph_agent/prompts/__init__.py b/aiGuider_Server/app/services/ar/langgraph_agent/prompts/__init__.py
index 506a08c..ba9bbdc 100644
--- a/aiGuider_Server/app/services/ar/langgraph_agent/prompts/__init__.py
+++ b/aiGuider_Server/app/services/ar/langgraph_agent/prompts/__init__.py
@@ -1,9 +1,9 @@
 """
-提示模板模块
+提示模板包
 
-管理系统提示和提示模板的加载
+包含系统提示和节点提示等
 """
 
-from .templates import load_system_prompt
+from .templates import load_system_prompt, load_thinker_prompt
 
-__all__ = ["load_system_prompt"] 
\ No newline at end of file
+__all__ = ["load_system_prompt", "load_thinker_prompt"] 
\ No newline at end of file
diff --git a/aiGuider_Server/app/services/ar/langgraph_agent/prompts/templates.py b/aiGuider_Server/app/services/ar/langgraph_agent/prompts/templates.py
index 1812a74..f3a9624 100644
--- a/aiGuider_Server/app/services/ar/langgraph_agent/prompts/templates.py
+++ b/aiGuider_Server/app/services/ar/langgraph_agent/prompts/templates.py
@@ -4,7 +4,8 @@
 用于加载和管理提示模板的模块
 """
 
-from .tour_guide import TOUR_GUIDE_PROMPT
+from .thinker import THINKER_PROMPT
+from .system import SYSTEM_PROMPT
 
 def load_system_prompt() -> str:
     """
@@ -13,5 +14,14 @@ def load_system_prompt() -> str:
     Returns:
         str: 系统提示内容
     """
-    # 直接返回导入的提示词内容
-    return TOUR_GUIDE_PROMPT 
\ No newline at end of file
+    # 使用系统整体提示词
+    return SYSTEM_PROMPT
+
+def load_thinker_prompt() -> str:
+    """
+    加载Thinker节点提示词
+    
+    Returns:
+        str: Thinker节点提示词内容
+    """
+    return THINKER_PROMPT 
\ No newline at end of file
diff --git a/aiGuider_Server/app/services/ar/langgraph_agent/prompts/tour_guide.py b/aiGuider_Server/app/services/ar/langgraph_agent/prompts/tour_guide.py
deleted file mode 100644
index aea8aef..0000000
--- a/aiGuider_Server/app/services/ar/langgraph_agent/prompts/tour_guide.py
+++ /dev/null
@@ -1,45 +0,0 @@
-"""
-AR智能导游助手提示模板
-"""
-
-TOUR_GUIDE_PROMPT = """# AR智能导游助手系统提示
-
-你是一位经验丰富的AR智能导游专家，拥有丰富的文化历史知识和景点讲解经验。你通过AR眼镜与用户实时互动，帮助他们深入了解所见景物。
-
-## 你的核心职责
-
-1. **图像识别与分析**: 精确识别用户通过AR眼镜看到的景点、建筑、文物或物品
-2. **知识传递**: 提供简洁但内容丰富的历史文化和科学背景信息
-3. **问题解答**: 回应用户具体提问，提供专业准确的回答
-4. **探索建议**: 推荐相关景点和最佳游览路线
-
-## 回答风格要求
-
-- **精炼**: 信息丰富但表达简洁，每个要点控制在1-2句话
-- **通俗**: 避免专业术语，使用大众能理解的语言
-- **生动**: 用具体细节和生动描述激发用户兴趣
-- **准确**: 基于事实，不添加臆测，不确定时明确表示
-- **适度幽默**: 在合适场合加入轻松元素提升体验
-
-## 工作流程
-
-1. **思考**: 仔细分析用户提供的图像，识别主要内容和特征
-2. **行动**: 基于识别结果提供相关背景信息
-3. **观察**: 注意用户的后续问题或反馈
-4. **响应**: 根据用户反馈调整回答深度和方向
-
-## 回答结构建议
-
-1. **简短开场**: 一句话确认识别结果
-2. **核心介绍**: 2-3段简洁的重要信息
-3. **延伸内容**: 可选的有趣细节或相关建议
-4. **引导互动**: 鼓励用户提问或探索相关景点
-
-## 特殊情况处理
-
-- **识别不确定时**: 坦诚说明不确定性，请求更多信息或不同角度图像
-- **知识边界**: 清晰表明知识限制，避免提供不确定信息
-- **图像不清晰**: 礼貌请求更清晰图像并解释原因
-- **仅有图像无文字**: 主动识别并提供主要信息，邀请用户进一步提问
-
-请记住，你的目标是通过准确、有趣且简洁的信息，丰富用户的旅游体验，让知识变得生动有趣。""" 
\ No newline at end of file
diff --git a/aiGuider_Server/app/services/ar/langgraph_agent/tools/__init__.py b/aiGuider_Server/app/services/ar/langgraph_agent/tools/__init__.py
index 66f3d93..d168f58 100644
--- a/aiGuider_Server/app/services/ar/langgraph_agent/tools/__init__.py
+++ b/aiGuider_Server/app/services/ar/langgraph_agent/tools/__init__.py
@@ -4,7 +4,6 @@
 包含Agent使用的各种工具
 """
 
-from .image_analyzer import ImageAnalyzer
-from .knowledge_retriever import KnowledgeRetriever
+from .knowledge_searcher import KnowledgeSearcher
 
-__all__ = ["ImageAnalyzer", "KnowledgeRetriever"] 
\ No newline at end of file
+__all__ = ["KnowledgeSearcher"] 
\ No newline at end of file
diff --git a/aiGuider_Server/app/services/ar/langgraph_agent/tools/image_analyzer.py b/aiGuider_Server/app/services/ar/langgraph_agent/tools/image_analyzer.py
deleted file mode 100644
index 49ea3e9..0000000
--- a/aiGuider_Server/app/services/ar/langgraph_agent/tools/image_analyzer.py
+++ /dev/null
@@ -1,102 +0,0 @@
-"""
-图像分析工具
-
-使用大语言模型分析图像内容
-"""
-
-import logging
-import base64
-from typing import Any, Optional, Dict, List, Union
-import re
-
-from langchain_core.messages import HumanMessage, SystemMessage
-
-logger = logging.getLogger(__name__)
-
-class ImageAnalyzer:
-    """
-    图像分析工具
-    
-    使用多模态大语言模型分析图像内容
-    """
-    
-    def __init__(self, model: Any):
-        """
-        初始化图像分析器
-        
-        Args:
-            model: 多模态大语言模型
-        """
-        self.model = model
-    
-    def analyze(self, image_data: str) -> str:
-        """
-        分析图像并返回描述
-        
-        Args:
-            image_data: 图像数据，可以是base64字符串或数据URL
-            
-        Returns:
-            str: 图像分析结果
-        """
-        logger.info("开始分析图像")
-        
-        try:
-            # 确保image_data是数据URL格式
-            if not image_data.startswith('data:image'):
-                # 尝试检测是否已经是base64编码
-                if self._is_base64(image_data):
-                    image_data = f"data:image/jpeg;base64,{image_data}"
-                else:
-                    raise ValueError("图像数据格式不正确，需要base64字符串或数据URL")
-            
-            # 创建分析提示
-            system_prompt = """
-            你是一个专业的图像分析助手。请详细分析以下图像，并提供以下信息：
-            1. 图像中主要内容的详细描述
-            2. 识别出的景点、建筑或物品名称
-            3. 图像中的文字内容（如果有）
-            4. 图像的风格和氛围
-            
-            请以结构化的方式回答，但不要使用标题和小标题，直接描述即可。
-            描述要详尽且准确，尽可能多地提供有用信息。
-            """
-            
-            # 创建消息内容
-            content = [
-                {"type": "text", "text": "请分析这张图片，提供详细描述。"},
-                {"type": "image_url", "image_url": {"url": image_data}}
-            ]
-            
-            # 创建消息
-            messages = [
-                SystemMessage(content=system_prompt),
-                HumanMessage(content=content)
-            ]
-            
-            # 调用模型
-            response = self.model.invoke(messages)
-            
-            # 处理响应
-            analysis = response.content
-            logger.info(f"图像分析完成: {analysis[:100]}...")
-            
-            return analysis
-        
-        except Exception as e:
-            logger.error(f"图像分析失败: {e}", exc_info=True)
-            return f"图像分析失败: {str(e)}"
-    
-    def _is_base64(self, s: str) -> bool:
-        """
-        检查字符串是否是有效的base64编码
-        
-        Args:
-            s: 要检查的字符串
-            
-        Returns:
-            bool: 是否是有效的base64编码
-        """
-        # 检查是否匹配base64模式
-        pattern = r'^[A-Za-z0-9+/]+={0,2}$'
-        return bool(re.match(pattern, s)) and len(s) % 4 == 0 
\ No newline at end of file
diff --git a/aiGuider_Server/app/services/ar/langgraph_agent/tools/knowledge_retriever.py b/aiGuider_Server/app/services/ar/langgraph_agent/tools/knowledge_retriever.py
deleted file mode 100644
index 3400ed9..0000000
--- a/aiGuider_Server/app/services/ar/langgraph_agent/tools/knowledge_retriever.py
+++ /dev/null
@@ -1,45 +0,0 @@
-"""
-知识检索工具
-
-从知识库中检索相关信息的接口，目前为占位实现
-"""
-
-import logging
-from typing import Dict, List, Optional, Any
-
-logger = logging.getLogger(__name__)
-
-class KnowledgeRetriever:
-    """
-    知识检索工具
-    
-    用于从知识库中检索相关信息的工具
-    """
-    
-    def __init__(self):
-        """
-        初始化知识检索工具
-        
-        目前为占位实现，未连接实际知识库
-        """
-        logger.info("初始化知识检索工具（占位实现）")
-    
-    def retrieve(self, query: str) -> str:
-        """
-        检索知识
-        
-        Args:
-            query: 查询内容
-            
-        Returns:
-            str: 检索结果
-        """
-        logger.info(f"检索知识: {query[:100] if query else '空查询'}...")
-        
-        # 目前返回占位信息
-        # 实际项目中，这里应该连接到向量数据库或其他知识检索系统
-        return (
-            "这是知识检索接口的占位实现。在实际项目中，"
-            "这里将连接到向量数据库或其他知识检索系统，"
-            "返回与查询相关的知识。"
-        ) 
\ No newline at end of file
